import asyncio
import glob
import hashlib
from loguru import logger
import os
import typing


class Artifact:
    """
    Artifact generated by a transformation.

    Args:
        name: Unique name of the artifact.

    Attrs:
        parent: Transformation that generates this artifact; :code:`None` if the artifact is a root
            of the directed acyclic graph.
        children: Transformations that consume this artifact; empty if the artifact is a leaf of the
            directed acyclic graph.
        digest: Concise summary of the artifact.
    """
    def __init__(self, name: str) -> None:
        if self.REGISTRY.setdefault(name, self) is not self:
            raise RuntimeError(f"artifact with name `{name}` already exists")
        self.name = name
        self._parent = None
        self.children = []

    @property
    def parent(self) -> 'Transformation':
        return self._parent

    @parent.setter
    def parent(self, value: 'Transformation') -> None:
        if self._parent is not None:
            raise RuntimeError(f"{self} is already associated with a transformation")
        self._parent = value

    @property
    def digest(self) -> bytes:
        return None

    def __repr__(self):
        return f"{self.__class__.__name__}({self.name})"

    async def __call__(self):
        if self.parent is None:
            return
        return await self.parent()

    REGISTRY = {}


class File(Artifact):
    """
    Artifact representing a file.
    """
    def __init__(self, name: str) -> None:
        super().__init__(name)
        self.filename = os.path.abspath(name)
        self._last_modified = None
        self._digest = None

    async def __call__(self):
        await super().__call__()
        if not os.path.exists(self.filename):
            if self._parent:
                message = f"{self._parent} did not generate {self}"
            else:
                message = f"{self} does not exist and cannot be generated"
            raise FileNotFoundError(message)

    @property
    def digest(self):
        try:
            # Only re-evaluate the digest if the file has not been modified since we last computed
            # the hash.
            last_modified = os.stat(self.filename).st_mtime
            if self._last_modified is None or self._last_modified < last_modified:
                algorithm = hashlib.sha256()
                with open(self.filename, 'rb') as fp:
                    while (chunk := fp.read(4096)):
                        algorithm.update(chunk)
                self._digest = algorithm.digest()
                self._last_modified = last_modified
            return self._digest
        except FileNotFoundError:
            return None

    @classmethod
    def glob(self, pattern):
        """
        Create a list of file artifacts based on a glob pattern.

        Args:
            pattern: Pattern passed to :func:`glob.glob`.

        Returns:
            artifacts: List of file artifacts.
        """
        return normalize_artifacts([filename for filename in glob.glob(pattern)])


def normalize_artifacts(artifacts) -> typing.Iterable[Artifact]:
    """
    Normalize one or more artifacts. Strings are implicitly converted to :class:`FileArtifact`s.

    Args:
        artifacts: One or more artifacts.

    Returns:
        normalized: List of normalized artifacts.
    """
    if artifacts is None:
        return []
    if not isinstance(artifacts, typing.Iterable) or isinstance(artifacts, str):
        artifacts = [artifacts]
    normalized = []
    for artifact in artifacts:
        if isinstance(artifact, str):
            try:
                candidate = Artifact.REGISTRY[artifact]
                if isinstance(candidate, File):
                    artifact = candidate
                else:
                    raise ValueError("only file artifacts can be implicitly referenced by name")
            except KeyError:
                artifact = File(artifact)
        elif not isinstance(artifact, Artifact):
            raise TypeError(artifact)
        normalized.append(artifact)
    return normalized


class Transformation:
    """
    Transformation that generates outputs given inputs.

    .. note::

       A transformation will be executed if any of its inputs or outputs have changed since the last
       execution. Consequently, manual changes to generated artifacts will be overwritten. A missing
       output is considered "changed" and will be generated if it is missing.

    Args:
        outputs: Artifacts to generate.
        inputs: Artifacts consumed by the transformation.
    """
    def __init__(self, outputs: typing.Iterable[Artifact], inputs: typing.Iterable[Artifact]) \
            -> None:
        self.inputs = normalize_artifacts(inputs)
        for input in self.inputs:
            input.children.append(self)
        self.outputs = normalize_artifacts(outputs)
        for output in self.outputs:
            output.parent = self
        self.future = None

    def __iter__(self):
        for output in self.outputs:
            yield output

    def evaluate_composite_digests(self) -> dict[Artifact, bytes]:
        # Initialise empty digests for the outputs.
        digests = {o.name: None for o in self.outputs}

        # Evaluate input digests and abort if any of them are missing.
        input_hasher = hashlib.sha256()
        for i in self.inputs:
            if i.digest is None:
                return digests
            input_hasher.update(i.digest)

        # Construct composite digests for the outputs.
        for output in self.outputs:
            if output.digest is None:
                continue
            hasher = input_hasher.copy()
            hasher.update(output.digest)
            digests[output.name] = hasher.hexdigest()
        return digests

    async def __call__(self) -> None:
        # Wait for all inputs to have been generated.
        await asyncio.gather(*(i() for i in self.inputs))

        # Check if any composite indices have changed. If no, there's nothing further to be done.
        composite_digests = self.evaluate_composite_digests()
        if all(digest is not None and digest == self.COMPOSITE_DIGESTS.get(name) for name, digest
               in composite_digests.items()):
            logger.debug('no inputs or outputs of {} have changed', self)
            return

        # Create a future if required and wait for it to complete.
        if not self.future:
            self.future = asyncio.create_task(self.execute())
        result = await self.future
        if result is not None:
            raise ValueError("transformations should return `None`")

        # Update the composite digests.
        self.COMPOSITE_DIGESTS.update(self.evaluate_composite_digests())

    async def execute(self):
        """
        Execute the transformation.
        """
        raise NotImplementedError

    def __repr__(self):
        inputs = ', '.join(map(repr, self.inputs))
        outputs = ', '.join(map(repr, self.outputs))
        return f"{self.__class__.__name__}([{inputs}] -> [{outputs}])"

    COMPOSITE_DIGESTS = {}
